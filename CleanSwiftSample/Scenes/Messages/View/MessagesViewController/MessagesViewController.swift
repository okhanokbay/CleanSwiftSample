//
//  MessagesViewController.swift
//  CleanSwiftSample
//
//  Created by Okhan Okbay on 24.10.2020.
//  Copyright (c) 2020 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol MessagesDisplayLogic: AnyObject {
  func displayInitials(viewModel: MessagesViewInitials.ViewModel)
  func displayMessages(viewModel: FetchMessages.ViewModel)
  func displayNewMessage(viewModel: NewMessage.ViewModel)
}

final class MessagesViewController: UIViewController {
  
  private var interactor: MessagesBusinessLogic!
  var router: (MessagesRoutingLogic & MessagesDataPassing)!
  
  @IBOutlet private weak var tableView: UITableView!
  private var tableViewDataSource: MessagesTableViewDataSource!
  
  private var messageInputView: MessageInputView!
  private let inputViewHeight: CGFloat = 50
  
  // MARK: Object lifecycle
  
  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
  }
  
  required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
    setup()
  }
  
  // MARK: Setup
  
  private func setup() {
    let dataStore = MessagesDataStore()
    let worker = MessagesWorker()
    let presenter = MessagesPresenter(displayer: self)
    let interactor = MessagesInteractor(dataStore: dataStore, worker: worker, presenter: presenter)
    let router = MessagesRouter(dataStore: dataStore, viewController: self)
    
    self.interactor = interactor
    self.router = router
    
    tableViewDataSource = MessagesTableViewDataSource()
  }
  
  override func viewDidLoad() {
    super.viewDidLoad()
    
    setupTableView()
    setupInitials()
    addNotificationObservers()
    fetchMessages()
  }
  
  override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
    
    setupBackButton()
    reloadInputViews()
  }
  
  override var canBecomeFirstResponder: Bool {
    return true
  }
  
  override var inputAccessoryView: UIView? {
    guard let messageInputView = messageInputView else {
      self.messageInputView = MessageInputView.loadFromNib()
      self.messageInputView.frame = .init(x: 0, y: 0, width: tableView.bounds.width, height: inputViewHeight)
      self.messageInputView.buttonSendTapped = inputAccessorySendButtonTapped()
      return self.messageInputView
    }
    
    return messageInputView
  }
  
  func inputAccessorySendButtonTapped() -> (String?) -> Void {
    return { [weak self] text in
      let request = NewMessage.Request(text: text)
      self?.interactor.sendMessage(request: request)
    }
  }
  
  func setupBackButton() {
    navigationController?.navigationBar.backItem?.title = Strings.leave
  }
  
  func setupTableView() {
    let cellClassString = String(describing: MessageTableViewCell.self)
    tableView.register(UINib(nibName: cellClassString, bundle: nil),
                       forCellReuseIdentifier: cellClassString)
    
    tableView.dataSource = tableViewDataSource
    tableView.backgroundColor = .white
  }
  
  func setupInitials() {
    let request = MessagesViewInitials.Request()
    interactor.setupInitials(request: request)
  }
  
  func fetchMessages() {
    let request = FetchMessages.Request()
    interactor.fetchMessages(request: request)
  }
}

extension MessagesViewController: MessagesDisplayLogic {
  func displayInitials(viewModel: MessagesViewInitials.ViewModel) {
    title = viewModel.title
  }
  
  func displayMessages(viewModel: FetchMessages.ViewModel) {
    switch viewModel.innerValue {
    case .success(let cellViewModels):
      tableViewDataSource.cellViewModels = cellViewModels
      
      DispatchQueue.main.async {
        self.tableView.reloadData()
      }
      
    case .failure(let alertViewModel):
      present(alertViewModel.alertController, animated: true, completion: nil)
    }
  }
  
  func displayNewMessage(viewModel: NewMessage.ViewModel) {
    tableViewDataSource.cellViewModels = viewModel.cellViewModels
    
    let lastRow = tableView.numberOfRows(inSection: 0)
    let indexPath = IndexPath(row: lastRow, section: 0)
    
    DispatchQueue.main.async {
      self.tableView.performBatchUpdates {
        // NS_NOESCAPE and nullable, since no retain cycles for this specific method
        // https://forums.swift.org/t/non-escaping-optional-closures-in-uikit/37565/2
        self.tableView.insertRows(at: [indexPath], with: .right)
      }
      
      self.tableView.scrollToRow(at: indexPath, at: .bottom, animated: true)
    }
  }
}

extension MessagesViewController {
  func addNotificationObservers() {
    NotificationCenter.default.addObserver(self, selector: #selector(keyboardDidShow(notification:)), name: UIResponder.keyboardDidShowNotification, object: nil)
  }
  
  @objc private func keyboardDidShow(notification: NSNotification) {
      if let keyboardSize = (notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue {
          tableView.contentInset = UIEdgeInsets(top: 0, left: 0, bottom: keyboardSize.height, right: 0)
      }
  }
}
